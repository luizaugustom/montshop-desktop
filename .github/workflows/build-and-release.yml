name: Build and Release

on:
  push:
    branches:
      - main  # Altere para 'master' se essa for sua branch principal
    tags:
      - 'v*'  # Dispara quando uma tag com formato v* √© criada
  workflow_dispatch:  # Permite executar manualmente pela interface do GitHub

jobs:
  build:
    runs-on: windows-latest
    permissions:
      contents: write  # Necess√°rio para criar releases e fazer upload de assets
      actions: read    # Leitura b√°sica de a√ß√µes
    
    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Necess√°rio para ter acesso completo ao hist√≥rico do git

      - name: Configurar Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Instalar depend√™ncias
        run: npm ci

      - name: Obter vers√£o do package.json
        id: package-version
        run: |
          $version = (Get-Content package.json | ConvertFrom-Json).version
          echo "version=$version" >> $env:GITHUB_OUTPUT
          echo "Vers√£o detectada: $version"

      - name: Build da aplica√ß√£o (sem publicar)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Build sem publicar (--publish=never para gerar arquivos mas n√£o criar release)
          npm run build:win -- --publish=never

      - name: Criar tag se n√£o existir
        id: tag
        uses: actions/github-script@v7
        env:
          VERSION: ${{ steps.package-version.outputs.version }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const version = process.env.VERSION;
            const tagName = `v${version}`;
            
            try {
              // Verificar se a tag j√° existe
              const { data: tag } = await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `tags/${tagName}`
              });
              
              console.log(`Tag ${tagName} j√° existe.`);
              core.setOutput('tag_exists', 'true');
            } catch (error) {
              if (error.status === 404) {
                // Tag n√£o existe, criar uma nova
                console.log(`Criando tag ${tagName}...`);
                
                // Obter SHA do commit atual
                const { data: ref } = await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: 'heads/main'
                });
                
                const sha = ref.object.sha;
                
                // Criar a tag
                await github.rest.git.createRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `refs/tags/${tagName}`,
                  sha: sha
                });
                
                console.log(`Tag ${tagName} criada com sucesso!`);
                core.setOutput('tag_exists', 'false');
              } else {
                throw error;
              }
            }

      - name: Criar ou obter Release
        id: release
        uses: actions/github-script@v7
        env:
          VERSION: ${{ steps.package-version.outputs.version }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const version = process.env.VERSION;
            const tagName = `v${version}`;
            
            // Verificar se j√° existe release
            const { data: releases } = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            
            let existingRelease = releases.find(
              release => release.tag_name === tagName
            );
            
            let releaseId;
            let uploadUrl;
            
            if (existingRelease) {
              console.log(`Release ${tagName} j√° existe. Usando release existente.`);
              releaseId = existingRelease.id;
              uploadUrl = existingRelease.upload_url;
            } else {
              console.log(`Criando nova release: ${tagName}`);
              const { data: release } = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: tagName,
                name: `MontShop Desktop v${version}`,
                body: `## üöÄ MontShop Desktop v${version}\n\n` +
                      `Atualiza√ß√£o autom√°tica criada pelo GitHub Actions.\n\n` +
                      `**Data:** ${new Date().toLocaleString('pt-BR')}\n\n` +
                      `**Commit:** ${context.sha.substring(0, 7)}\n\n` +
                      `### üì• Instala√ß√£o\n\n` +
                      `1. Baixe o arquivo \`MontShop-Desktop-Setup-${version}.exe\`\n` +
                      `2. Execute o instalador\n` +
                      `3. A aplica√ß√£o ser√° atualizada automaticamente na pr√≥xima vez que abrir\n\n` +
                      `### ‚ö° Atualiza√ß√£o Autom√°tica\n\n` +
                      `Se voc√™ j√° tem o MontShop Desktop instalado, a atualiza√ß√£o ser√° baixada e instalada automaticamente ao fechar o aplicativo.`,
                draft: false,
                prerelease: false
              });
              
              releaseId = release.id;
              uploadUrl = release.upload_url;
              console.log(`Release criada: ${release.html_url}`);
            }
            
            core.setOutput('release_id', releaseId);
            core.setOutput('upload_url', uploadUrl);

      - name: Fazer upload do instalador (.exe)
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ steps.release.outputs.release_id }}
          UPLOAD_URL: ${{ steps.release.outputs.upload_url }}
          VERSION: ${{ steps.package-version.outputs.version }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const filePath = `./release/MontShop-Desktop-Setup-${process.env.VERSION}.exe`;
            
            if (!fs.existsSync(filePath)) {
              throw new Error(`Arquivo n√£o encontrado: ${filePath}`);
            }
            
            const fileContent = fs.readFileSync(filePath);
            const fileName = path.basename(filePath);
            const releaseId = parseInt(process.env.RELEASE_ID);
            
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              name: fileName,
              data: fileContent,
              headers: {
                'content-type': 'application/octet-stream',
                'content-length': fileContent.length
              }
            });
            
            console.log(`‚úÖ Arquivo ${fileName} enviado com sucesso!`);

      - name: Fazer upload do latest.yml (para atualiza√ß√£o autom√°tica)
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ steps.release.outputs.release_id }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const filePath = './release/latest.yml';
            const releaseId = parseInt(process.env.RELEASE_ID);
            
            if (!fs.existsSync(filePath)) {
              console.log('‚ö†Ô∏è Arquivo latest.yml n√£o encontrado. Tentando localizar...');
              // Tentar encontrar em subdiret√≥rios
              const releaseDir = './release';
              if (fs.existsSync(releaseDir)) {
                const files = fs.readdirSync(releaseDir, { recursive: true });
                const ymlFile = files.find(f => f.includes('latest.yml') || (f.endsWith('.yml') && f.includes('latest')));
                
                if (ymlFile) {
                  const fullPath = path.join(releaseDir, ymlFile);
                  console.log(`‚úÖ Encontrado: ${fullPath}`);
                  const fileContent = fs.readFileSync(fullPath);
                  
                  await github.rest.repos.uploadReleaseAsset({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: releaseId,
                    name: 'latest.yml',
                    data: fileContent,
                    headers: {
                      'content-type': 'application/x-yaml',
                      'content-length': fileContent.length
                    }
                  });
                  
                  console.log('‚úÖ Arquivo latest.yml enviado com sucesso!');
                } else {
                  console.log('‚ö†Ô∏è Arquivo latest.yml n√£o encontrado. O electron-builder pode n√£o ter gerado ainda.');
                  console.log('Isso n√£o √© cr√≠tico - o electron-updater ainda funcionar√° sem este arquivo.');
                }
              }
            } else {
              const fileContent = fs.readFileSync(filePath);
              
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: releaseId,
                name: 'latest.yml',
                data: fileContent,
                headers: {
                  'content-type': 'application/x-yaml',
                  'content-length': fileContent.length
                }
              });
              
              console.log('‚úÖ Arquivo latest.yml enviado com sucesso!');
            }

      - name: Resumo do build
        run: |
          echo "‚úÖ Build conclu√≠do com sucesso!"
          echo "üì¶ Vers√£o: ${{ steps.package-version.outputs.version }}"
          echo "üîó Release: https://github.com/${{ github.repository }}/releases/tag/v${{ steps.package-version.outputs.version }}"
          echo ""
          echo "Os usu√°rios receber√£o a atualiza√ß√£o automaticamente quando abrirem o aplicativo."

